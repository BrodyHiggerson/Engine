#include "lib.esh"
#include "lights.esh"

cbuffer ViewCBuffer
{
	ViewParams v_;
};

cbuffer LightCBuffer
{
	LightParams l_;
};

struct Object
{
	float4x4 world_;
};

StructuredBuffer<Object> inObject;


struct VS_IN
{
	float3 position : POSITION;
	float3 normal : NORMAL;
};

struct VS_OUT
{
	float4 position : SV_POSITION;
	float3 w_position : TEXCOORD15;
	float3 normal : NORMAL;
};

VS_OUT vs_main(in VS_IN _in, uint _id : SV_INSTANCEID)
{
	Object o = inObject[0];

	VS_OUT _out = (VS_OUT)0;
	float4 position = mul(o.world_, float4(_in.position, 1.0));
	_out.position = mul(v_.viewProj_, position);
	_out.w_position = position.xyz;
	_out.normal = mul((float3x3)o.world_, _in.normal);
	return _out;
}

void ps_depthprepass(in VS_OUT _in)
{
	
}

StructuredBuffer<Light> inLights;
StructuredBuffer<LightLink> inLightLinks;

float4 ps_forward(in VS_OUT _in) : SV_TARGET0
{
	const float3 normal = normalize(_in.normal.xyz);
	const float3 ambient = float3(0.1, 0.1, 0.1);

	float3 lightColor = float3(0.0, 0.0, 0.0);
	lightColor += ambient;

	float2 viewCoord = _in.position.xy / v_.screenDimensions_;
	const uint tileIdx = GetTileIdx(l_, viewCoord * l_.numTiles_);

	// Iterate over lights.
	LightLink lightLink = inLightLinks[tileIdx];
	for(int idx = 0; idx < MAX_LIGHTS_PER_TILE; ++idx)
	{	
		if(lightLink.idx >= 0)
		{
			const Light light = inLights[lightLink.idx];
			const float3 lightVec = light.position_ - _in.w_position;
			const float dist = sqrt(dot(lightVec, lightVec));
			const float3 lightDir = lightVec / dist; 
			const float attn = CalculateAttn(dist, light.attenuation_);

			lightColor += light.color_ * max(0.0, dot(normal, lightDir) * attn);
		}

		if(lightLink.next == 0)
			break;
		lightLink = inLightLinks[lightLink.next];
	}

	return float4(lightColor, 1.0);
}

float4 ps_shadow(in VS_OUT _in) : SV_TARGET0
{
	return float4(1.0, 0.0, 1.0, 1.0);
}

RenderState RS_DEPTH_PREPASS =
{
	.BlendStates = {
		.WriteMask = 0,
	},

	.DepthFunc = LESS_EQUAL,
	.DepthEnable = 1,
	.DepthWriteMask = 1,
	.FillMode = SOLID,
};

RenderState RS_FORWARD =
{
	.DepthFunc = LESS_EQUAL,
	.DepthEnable = 1,
	.DepthWriteMask = 1,
	.FillMode = SOLID,
};

RenderState RS_SHADOW =
{
	.DepthFunc = LESS_EQUAL,
	.DepthEnable = 1,
	.DepthWriteMask = 1,
	.FillMode = SOLID,
};

Technique RenderPassDepthPrepass =
{
	.VertexShader = vs_main,
	.PixelShader = ps_depthprepass,
	.RenderState = RS_DEPTH_PREPASS,
};

Technique RenderPassForward =
{
	.VertexShader = vs_main,
	.PixelShader = ps_forward,
	.RenderState = RS_FORWARD,
};

Technique RenderPassShadow =
{
	.VertexShader = vs_main,
	.PixelShader = ps_shadow,
	.RenderState = RS_SHADOW,
};
